<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MessiahBot — Dashboard</title>
  <link rel="preload" href="{{ url_for('static', filename='fonts/XLOELX.woff2') }}" as="font" type="font/woff2" crossorigin>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}">
  <script src="https://unpkg.com/htmx.org@1.0.10" defer></script>
  <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.2/Sortable.min.js" defer></script>
</head>
<body>
  <nav class="topnav">
    <div class="topnav__brand">MessiahBot</div>
    <div class="topnav__env">ENV: <strong>{{ env }}</strong></div>
  </nav>

  <main class="container">
    <section class="grid grid--3">
      <div class="card">
        <h2>Discord</h2>
        <p id="discordStatus" class="muted">Loading…</p>
        <div class="actions">
          <a class="btn btn--primary" href="/login">Login with Discord</a>
        </div>
      </div>

      <div class="card">
        <h2>Twitch</h2>
        <p id="twitchStatus" class="muted">Loading…</p>
        <div class="actions">
          <a class="btn" href="/connect_twitch">Connect Twitch</a>
        </div>
      </div>

      <div class="card">
        <h2>Plex</h2>
        <p id="plexStatus" class="muted">Checking…</p>
        <div class="actions">
          <button class="btn" id="btnPlexCheck">Refresh Plex Status</button>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="card__hdr">
        <h2>Server Builder</h2>
        <div class="card__hdrActions" id="builderActions" style="display: none;">
          <button class="btn-small" id="btnDebugToggle" style="display:none;">Debug</button>
          <button class="btn" id="btnLoadLive" disabled>Load from Live</button>
          <button class="btn" id="btnLoadSnapshot" disabled>Load Snapshot</button>
          <button class="btn btn--primary" id="btnSave" disabled>Save Layout</button>
        </div>
      </div>

      <div id="builderNote" class="muted">Choose a server and load its current layout, or edit and save.</div>

      <div class="formRow">
        <label for="guildSelect">Select Server</label>
        <select id="guildSelect">
          {% for g in session.guilds %}
            <option value="{{ g.id }}">
              {{ g.name }}
            </option>
          {% endfor %}
        </select>

        <!-- hidden field used by JS -->
        <input type="hidden" id="guildId">
      </div>

      <div id="layoutBuilder" x-data="{ layout: [], roles: [] }">

        <div class="builder-grid">
          <div class="builder-panel">
            <h3>Categories & Channels</h3>
            <div id="categoryList"></div>
            <button class="btn" id="btnAddCategory">+ Add Category</button>
          </div>

          <div class="builder-panel">
            <h3>Roles</h3>
            <div id="roleList"></div>
            <button class="btn" id="btnAddRole">+ Add Role</button>
          </div>
        </div>
      
      </div>
      
      <div class="json-raw flex-column" style="display: flex; flex-direction: column; gap: 1.5rem;">
        <div>
          <label>Roles (JSON)</label>
          <textarea id="rolesJson" rows="18" placeholder="[ /* roles appear here after Load from Live */ ]"></textarea>
        </div>
        <div>
          <label>Categories/Channels (JSON)</label>
          <textarea id="layoutJson" rows="18" placeholder="{ /* structure will appear here after Load from Live */ }"></textarea>
        </div>
      </div>
    </section>
  </main>

  <footer class="footer">
    <div class="footer__inner">
      <span>Environment:</span>
      <code>{{ env }}</code>
    </div>
  </footer>

<script>
let rolesState = [];

const DEV_ID = "757250912602554449";
const debugToggle = document.getElementById("btnDebugToggle");
const rawJsonBlock = document.querySelector(".json-raw");
const envBadge = document.querySelector(".topnav__env");

function el(id){ return document.getElementById(id); }

function collectLayoutFromUI() {
  const categories = [];
  document.querySelectorAll(".category-block").forEach(block => {
    const nameInput = block.querySelector(".category-name");
    const name = nameInput ? nameInput.value : "";

    const textRows = block.querySelectorAll(".text-channel-list .channel-row");
    const voiceRows = block.querySelectorAll(".voice-channel-list .channel-row");

    const channels = [];
    let pos = 0;

    // Text-like channels first
    Array.from(textRows).forEach(row => {
      const typeSpan = row.querySelector(".channel-type");
      const rawType = (typeSpan?.dataset.type || typeSpan?.textContent || "text").toLowerCase().trim();
      const type = rawType || "text";
      const nameVal = row.querySelector(".channel-name")?.value || "";
      channels.push({
        type,
        name: nameVal,
        options: {},
        position: pos++
      });
    });

    // Voice-like channels after text/forum
    Array.from(voiceRows).forEach(row => {
      const typeSpan = row.querySelector(".channel-type");
      const rawType = (typeSpan?.dataset.type || typeSpan?.textContent || "voice").toLowerCase().trim();
      const type = rawType || "voice";
      const nameVal = row.querySelector(".channel-name")?.value || "";
      channels.push({
        type,
        name: nameVal,
        options: {},
        position: pos++
      });
    });

    categories.push({
      name,
      channels,
      position: categories.length
    });
  });
  return categories;
}

function saveVisualToJson() {
  const categories = collectLayoutFromUI();

  // Layout JSON: normalized payload the bot expects
  const layoutPayload = {
    mode: "update",
    categories: categories,
    channels: []
  };
  const layoutBox = document.getElementById("layoutJson");
  if (layoutBox) {
    layoutBox.value = JSON.stringify(layoutPayload, null, 2);
  }

  // Roles JSON: from the current rolesState
  const rolesBox = document.getElementById("rolesJson");
  if (rolesBox) {
    rolesBox.value = JSON.stringify(rolesState, null, 2);
  }
}

function renderLayout(layout) {
  const container = document.getElementById("categoryList");
  if (!container) return;
  container.innerHTML = "";

  const categories = Array.isArray(layout)
    ? layout.slice().sort((a, b) => (a.position ?? 0) - (b.position ?? 0))
    : [];

  categories.forEach((cat, catIndex) => {
    const catDiv = document.createElement("div");
    catDiv.className = "category-block";

    const textListId = `text-channels-${catIndex}`;
    const voiceListId = `voice-channels-${catIndex}`;

    catDiv.innerHTML = `
      <div class="category-header">
        <span class="category-handle">☰</span>
        <input class="category-name" value="${cat.name || ""}" placeholder="Category name">
      </div>
      <div class="channel-groups">
        <div class="channel-group channel-group--text">
          <div class="channel-group-header">Text &amp; Forum Channels</div>
          <div class="channel-list text-channel-list" id="${textListId}"></div>
          <button type="button" class="btn-small add-text-channel-btn" data-cat-index="${catIndex}">+ Text / Forum</button>
        </div>
        <div class="channel-group channel-group--voice">
          <div class="channel-group-header">Voice &amp; Stage Channels</div>
          <div class="channel-list voice-channel-list" id="${voiceListId}"></div>
          <button type="button" class="btn-small add-voice-channel-btn" data-cat-index="${catIndex}">+ Voice / Stage</button>
        </div>
      </div>
    `;

    container.appendChild(catDiv);

    const textList = document.getElementById(textListId);
    const voiceList = document.getElementById(voiceListId);

    const textLike = Array.isArray(cat.channels_text)
      ? cat.channels_text.slice().sort((a, b) => (a.position ?? 0) - (b.position ?? 0))
      : [];

    const voiceLike = Array.isArray(cat.channels_voice)
      ? cat.channels_voice.slice().sort((a, b) => (a.position ?? 0) - (b.position ?? 0))
      : [];

    textLike.forEach(ch => {
      const normalizedType = "text";
      const row = document.createElement("div");
      row.className = "channel-row";
      row.innerHTML = `
        <span class="channel-type" data-type="text">text</span>
        <input class="channel-name" value="${ch.name || ""}" placeholder="text-channel">
      `;
      textList.appendChild(row);
    });

    voiceLike.forEach(ch => {
      const normalizedType = "voice";
      const row = document.createElement("div");
      row.className = "channel-row";
      row.innerHTML = `
        <span class="channel-type" data-type="voice">voice</span>
        <input class="channel-name" value="${ch.name || ""}" placeholder="voice-channel">
      `;
      voiceList.appendChild(row);
    });

    // Make each list sortable within the category
    if (window.Sortable && textList) {
      new Sortable(textList, {
        animation: 150,
        onEnd: () => saveVisualToJson()
      });
    }
    if (window.Sortable && voiceList) {
      new Sortable(voiceList, {
        animation: 150,
        onEnd: () => saveVisualToJson()
      });
    }
  });

  // Make categories sortable
  if (window.Sortable && container) {
    new Sortable(container, {
      animation: 150,
      handle: ".category-handle",
      onEnd: () => saveVisualToJson()
    });
  }

  // Wire up "Add Text" / "Add Voice" buttons
  container.querySelectorAll(".add-text-channel-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const idx = parseInt(btn.getAttribute("data-cat-index") || "0", 10);
      addChannel(idx, "text");
    });
  });

  container.querySelectorAll(".add-voice-channel-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const idx = parseInt(btn.getAttribute("data-cat-index") || "0", 10);
      addChannel(idx, "voice");
    });
  });

  // Sync JSON after an initial render
  saveVisualToJson();
}

function renderRoles(roles) {
  const list = document.getElementById("roleList");
  if (!list) return;

  // Prepare a base list with original index for stable fallback ordering
  const base = (roles || []).map((r, idx) => ({
    ...r,
    _origIndex: idx
  }));

  // Discord UI shows higher "position" at the top of the list,
  // so we sort DESC by position. If no position is present,
  // we fall back to the original array index.
  const sorted = base.slice().sort((a, b) => {
    const pa = (typeof a.position === "number") ? a.position : a._origIndex;
    const pb = (typeof b.position === "number") ? b.position : b._origIndex;
    return pb - pa; // higher position first
  });

  // rolesState keeps the current UI order and propagates position forward
  rolesState = sorted.map(r => ({
    name: r.name || "",
    color: r.color || "#000000",
    position: r.position
  }));

  list.innerHTML = "";

  rolesState.forEach((role, idx) => {
    const row = document.createElement("div");
    row.className = "role-row";
    row.dataset.index = String(idx);

    row.innerHTML = `
      <span class="role-handle">☰</span>
      <input class="role-name" value="${role.name}" placeholder="Role name">
      <input class="role-color" type="color" value="${role.color}" style="width: 36px; height: 28px; padding: 0; border: none; cursor: pointer;">
      <button type="button" class="btn-small role-delete">✕</button>
    `;

    const nameInput = row.querySelector(".role-name");
    const colorInput = row.querySelector(".role-color");
    const delBtn = row.querySelector(".role-delete");

    if (nameInput) {
      nameInput.addEventListener("input", () => {
        rolesState[idx].name = nameInput.value;
        saveVisualToJson();
      });
    }
    if (colorInput) {
      colorInput.addEventListener("input", () => {
        rolesState[idx].color = colorInput.value || "#000000";
        saveVisualToJson();
      });
    }
    if (delBtn) {
      delBtn.addEventListener("click", () => {
        rolesState.splice(idx, 1);
        renderRoles(rolesState);
        saveVisualToJson();
      });
    }

    list.appendChild(row);
  });

  // Make roles sortable in the UI; when the user drags, we
  // adopt the new visual order as the new authoritative order.
  if (window.Sortable && list) {
    new Sortable(list, {
      animation: 150,
      handle: ".role-handle",
      onEnd: () => {
        const newOrder = [];
        list.querySelectorAll(".role-row").forEach(row => {
          const i = parseInt(row.dataset.index || "0", 10);
          if (!Number.isNaN(i) && rolesState[i]) {
            newOrder.push(rolesState[i]);
          }
        });
        if (newOrder.length === rolesState.length) {
          rolesState = newOrder;
          renderRoles(rolesState);
          saveVisualToJson();
        }
      }
    });
  }

  // Sync JSON after render
  saveVisualToJson();
}

function addCategory() {
  const container = document.getElementById("categoryList");
  if (!container) return;

  const catIndex = container.querySelectorAll(".category-block").length;
  const textListId = `text-channels-${catIndex}`;
  const voiceListId = `voice-channels-${catIndex}`;

  const catDiv = document.createElement("div");
  catDiv.className = "category-block";
  catDiv.innerHTML = `
    <div class="category-header">
      <span class="category-handle">☰</span>
      <input class="category-name" value="" placeholder="New category">
    </div>
    <div class="channel-groups">
      <div class="channel-group channel-group--text">
        <div class="channel-group-header">Text &amp; Forum Channels</div>
        <div class="channel-list text-channel-list" id="${textListId}"></div>
        <button type="button" class="btn-small add-text-channel-btn" data-cat-index="${catIndex}">+ Text / Forum</button>
      </div>
      <div class="channel-group channel-group--voice">
        <div class="channel-group-header">Voice &amp; Stage Channels</div>
        <div class="channel-list voice-channel-list" id="${voiceListId}"></div>
        <button type="button" class="btn-small add-voice-channel-btn" data-cat-index="${catIndex}">+ Voice / Stage</button>
      </div>
    </div>
  `;

  container.appendChild(catDiv);

  const textList = document.getElementById(textListId);
  const voiceList = document.getElementById(voiceListId);

  if (window.Sortable && textList) {
    new Sortable(textList, {
      animation: 150,
      onEnd: () => saveVisualToJson()
    });
  }
  if (window.Sortable && voiceList) {
    new Sortable(voiceList, {
      animation: 150,
      onEnd: () => saveVisualToJson()
    });
  }

  catDiv.querySelector(".add-text-channel-btn")?.addEventListener("click", () => {
    addChannel(catIndex, "text");
  });
  catDiv.querySelector(".add-voice-channel-btn")?.addEventListener("click", () => {
    addChannel(catIndex, "voice");
  });

  saveVisualToJson();
}

function addChannel(catIndex, kind = "text") {
  const blocks = document.querySelectorAll(".category-block");
  const block = blocks[catIndex];
  if (!block) return;

  const listSelector = (kind === "voice" || kind === "stage")
    ? ".voice-channel-list"
    : ".text-channel-list";

  const list = block.querySelector(listSelector);
  if (!list) return;

  const normalizedType = (kind === "voice" || kind === "stage") ? "voice" : "text";

  const row = document.createElement("div");
  row.className = "channel-row";
  row.innerHTML = `
    <span class="channel-type" data-type="${normalizedType}">${normalizedType}</span>
    <input class="channel-name" value="" placeholder="${normalizedType === "voice" ? "new-voice-channel" : "new-channel"}">
  `;
  list.appendChild(row);

  saveVisualToJson();
}

document.addEventListener("DOMContentLoaded", () => {
  const guildSelect = document.getElementById("guildSelect");
  const btnLoadLive = document.getElementById("btnLoadLive");
  const btnLoadSnapshot = document.getElementById("btnLoadSnapshot");
  const btnSave = document.getElementById("btnSave");
  const builderActions = document.getElementById("builderActions");

  guildSelect.addEventListener("change", () => {
    const has = !!guildSelect.value.trim();
    btnLoadLive.disabled = !has;
    btnLoadSnapshot.disabled = !has;
    btnSave.disabled = !has;
    if (builderActions) {
      builderActions.style.display = has ? "flex" : "none";
    }
  });

  function setStatus(id, text, ok=true){
    const node = el(id);
    node.textContent = text;
    node.className = ok ? "ok" : "err";
  }

  async function loadStatuses(){
    try {
      const who = await fetch("/whoami").then(r => r.json());

      // Debug toggle logic
      if (who.user && who.user.id === DEV_ID) {
          debugToggle.style.display = "inline-block";
      } else {
          debugToggle.style.display = "none";
          if (rawJsonBlock) rawJsonBlock.style.display = "none";
          if (envBadge) envBadge.style.display = "none";
      }

      if (who.logged_in) {
        setStatus("discordStatus", `Logged in as ${who.user.username}`, true);

        // Hide the "Login with Discord" button once logged in
        const loginBtn = document.querySelector('a[href="/login"]');
        if (loginBtn) loginBtn.style.display = "none";

        // --- Build OWNED-ONLY dropdown (Option B) ---
        // Always start with a clean placeholder option
        guildSelect.innerHTML = '<option value="">— Select a server —</option>';

        const ownedGuilds = (who.guilds || []).filter(g => g.owner);

        if (ownedGuilds.length) {
          for (const g of ownedGuilds) {
            const opt = document.createElement("option");
            opt.value = g.id;
            opt.textContent = g.name;
            guildSelect.appendChild(opt);
          }
        } else {
          // No owned servers: show a disabled message option
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No owned servers found";
          opt.disabled = true;
          opt.selected = true;
          guildSelect.appendChild(opt);
        }

        // Option B: keep all actions hidden/disabled until the user actually selects a server
        if (builderActions) {
          builderActions.style.display = "none";
        }
        btnLoadLive.disabled = true;
        btnLoadSnapshot.disabled = true;
        btnSave.disabled = true;

        // Force the change handler to run once to sync button disabled state
        guildSelect.dispatchEvent(new Event("change"));
      } else {
        setStatus("discordStatus", "Not logged in", false);

        // Not logged in: make sure actions are hidden/disabled and dropdown reset
        guildSelect.innerHTML = '<option value="">— Select a server —</option>';
        if (builderActions) {
          builderActions.style.display = "none";
        }
        btnLoadLive.disabled = true;
        btnLoadSnapshot.disabled = true;
        btnSave.disabled = true;
      }

      // Twitch status
      const env = await fetch("/envcheck").then(r => r.json());
      setStatus("twitchStatus", env.twitch ? "Connected" : "Not connected", !!env.twitch);

      // Plex status
      const plexResp = await fetch("/plex/status").then(r => r.json());
      if (plexResp.ok) {
        setStatus("plexStatus", "Plex reachable", true);
      } else {
        setStatus("plexStatus", "Not configured or unreachable", false);
      }
    } catch (e) {
      console.error("Status init error:", e);
    }
  }

  // Hide controls until selection
  el("btnLoadLive").style.display = "none";
  el("btnLoadSnapshot").style.display = "none";

  el("guildSelect").addEventListener("change", () => {
      const gid = el("guildSelect").value;
      if (gid) {
          el("btnLoadLive").style.display = "inline-block";
          el("btnLoadSnapshot").style.display = "inline-block";
          el("guildId").value = gid;
      } else {
          el("btnLoadLive").style.display = "none";
          el("btnLoadSnapshot").style.display = "none";
      }
  });

  el("btnPlexCheck").addEventListener("click", async () => {
    try {
      const r = await fetch("/plex/status").then(r=>r.json());
      if (r.ok){
        setStatus("plexStatus", "Plex reachable (code " + (r.status_code || 200) + ")", true);
      } else {
        setStatus("plexStatus", "Plex error: " + (r.error || r.status_code), false);
      }
    }catch(e){
      setStatus("plexStatus", "Plex error: " + e.message, false);
    }
  });

  const btnAddCategory = document.getElementById("btnAddCategory");
  const btnAddRole = document.getElementById("btnAddRole");

  if (btnAddCategory) {
    btnAddCategory.addEventListener("click", () => {
      addCategory();
    });
  }

  if (btnAddRole) {
    btnAddRole.addEventListener("click", () => {
      rolesState.push({ name: "", color: "#000000" });
      renderRoles(rolesState);
    });
  }

  el("btnLoadLive").addEventListener("click", async () => {
    const gid = guildSelect.value.trim();
    if (!gid){ alert("Select a server first"); return; }

    try {
      const res = await fetch(`/api/live_layout/${gid}`);
      if (!res.ok) {
        const text = await res.text();
        throw new Error("HTTP " + res.status + " — " + text.slice(0, 200));
      }
      const ct = res.headers.get("content-type") || "";
      if (!ct.includes("application/json")) {
        const text = await res.text();
        throw new Error("Non-JSON response: " + text.slice(0, 200));
      }

      const data = await res.json();
      const categories = data.categories || data.categories_channels || [];
      const roles = data.roles || [];

      renderLayout(categories);
      renderRoles(roles);

      el("builderNote").textContent = "Loaded live layout for guild " + gid;
    } catch (e){
      console.error(e);
      el("builderNote").textContent = "Failed to load from live: " + e.message;
    }
  });

  document.getElementById("btnLoadSnapshot").addEventListener("click", async () => {
    const gid = guildSelect.value.trim();
    if (!gid){ alert("Select a server first"); return; }

    try {
      const res = await fetch(`/api/snapshot/${gid}`);
      if (!res.ok) {
        const text = await res.text();
        throw new Error("HTTP " + res.status + " — " + text.slice(0, 200));
      }
      const ct = res.headers.get("content-type") || "";
      if (!ct.includes("application/json")) {
        const text = await res.text();
        throw new Error("Non-JSON response: " + text.slice(0, 200));
      }

      const snap = await res.json();
      if (!snap || !snap.ok || !snap.payload){
        el("builderNote").textContent = "No snapshot found.";
        return;
      }

      const payload = snap.payload;
      const categories = payload.categories || payload.categories_channels || [];
      const roles = payload.roles || [];

      renderLayout(categories);
      renderRoles(roles);

      el("builderNote").textContent = "Loaded snapshot for guild " + gid;
    } catch(e){
      console.error(e);
      el("builderNote").textContent = "Snapshot load failed: " + e.message;
    }
  });

  el("btnSave").addEventListener("click", async () => {
    const gid = guildSelect.value.trim();
    if (!gid){ alert("Select a server first"); return; }

    const categories = collectLayoutFromUI();
    const layout = {
      mode: "update",
      categories: categories,
      channels: []
    };
    const roles = rolesState.slice();

    const payload = { guild_id: gid, layout, roles };

    const resp = await fetch("/submit-server-layout", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (resp.ok){
      el("builderNote").textContent = "Saved layout for guild " + gid;
    } else {
      const t = await resp.text();
      el("builderNote").textContent = "Save failed: " + t;
    }
  });

  // Debug toggle event
  if (debugToggle && rawJsonBlock && envBadge) {
    debugToggle.addEventListener("click", () => {
      const open = rawJsonBlock.style.display !== "none";
      rawJsonBlock.style.display = open ? "none" : "flex";
      envBadge.style.display = open ? "none" : "inline-block";
    });
  }

  loadStatuses();
});
</script>

</body>
</html>