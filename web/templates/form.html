<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MessiahBot — Dashboard</title>
  <link rel="preload" href="{{ url_for('static', filename='fonts/XLOELX.woff2') }}" as="font" type="font/woff2" crossorigin>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}">
  <script src="https://unpkg.com/htmx.org@1.0.10" defer></script>
  <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajac/libs/Sortable/1.15.2/Sortable.min.js" defer></script>
</head>
<body>
  <nav class="topnav">
    <div class="topnav__brand">MessiahBot</div>
    <div class="topnav__env">ENV: <strong>{{ env }}</strong></div>
  </nav>

  <main class="container">
    <section class="grid grid--3">
      <div class="card">
        <h2>Discord</h2>
        <p id="discordStatus" class="muted">Loading…</p>
        <div class="actions">
          <a class="btn btn--primary" href="/login">Login with Discord</a>
        </div>
      </div>

      <div class="card">
        <h2>Twitch</h2>
        <p id="twitchStatus" class="muted">Loading…</p>
        <div class="actions">
          <a class="btn" href="/connect_twitch">Connect Twitch</a>
        </div>
      </div>

      <div class="card">
        <h2>Plex</h2>
        <p id="plexStatus" class="muted">Checking…</p>
        <div class="actions">
          <button class="btn" id="btnPlexCheck">Refresh Plex Status</button>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="card__hdr">
        <h2>Server Builder</h2>
        <div class="card__hdrActions" id="builderActions" style="display: none;">
          <button class="btn" id="btnLoadLive" disabled>Load from Live</button>
          <button class="btn" id="btnLoadSnapshot" disabled>Load Snapshot</button>
          <button class="btn btn--primary" id="btnSave" disabled>Save Layout</button>
        </div>
      </div>

      <div id="builderNote" class="muted">Choose a server and load its current layout, or edit and save.</div>

      <div class="formRow">
        <label for="guildSelect">Select Server</label>
        <select id="guildSelect">
          {% for g in session.guilds %}
            <option value="{{ g.id }}">
              {{ g.name }}
            </option>
          {% endfor %}
        </select>

        <!-- hidden field used by JS -->
        <input type="hidden" id="guildId">
      </div>

      <div id="layoutBuilder" x-data="{ layout: [], roles: [] }">

        <div class="builder-grid">
          <div class="builder-panel">
            <h3>Categories & Channels</h3>
            <div id="categoryList"></div>
            <button class="btn" id="btnAddCategory">+ Add Category</button>
          </div>

          <div class="builder-panel">
            <h3>Roles</h3>
            <div id="roleList"></div>
            <button class="btn" id="btnAddRole">+ Add Roles</button>
          </div>
        </div>
      
      </div>
      
      <div class="json-raw flex-column" style="display: flex; flex-direction: column; gap: 1.5rem;">
        <div>
          <label>Roles (JSON)</label>
          <textarea id="rolesJson" rows="18" placeholder="[ /* roles appear here after Load from Live */ ]"></textarea>
        </div>
        <div>
          <label>Categories/Channels (JSON)</label>
          <textarea id="layoutJson" rows="18" placeholder="{ /* structure will appear here after Load from Live */ }"></textarea>
        </div>
      </div>
    </section>
  </main>

  <footer class="footer">
    <div class="footer__inner">
      <span>Environment:</span>
      <code>{{ env }}</code>
    </div>
  </footer>

<script>
document.addEventListener("DOMContentLoaded", () => {
  function el(id){ return document.getElementById(id); }

  const guildSelect = document.getElementById("guildSelect");
  const btnLoadLive = document.getElementById("btnLoadLive");
  const btnLoadSnapshot = document.getElementById("btnLoadSnapshot");
  const btnSave = document.getElementById("btnSave");
  const builderActions = document.getElementById("builderActions");

  guildSelect.addEventListener("change", () => {
    const has = !!guildSelect.value.trim();
    btnLoadLive.disabled = !has;
    btnLoadSnapshot.disabled = !has;
    btnSave.disabled = !has;
    if (builderActions) {
      builderActions.style.display = has ? "flex" : "none";
    }
  });

  function setStatus(id, text, ok=true){
    const node = el(id);
    node.textContent = text;
    node.className = ok ? "ok" : "err";
  }

  async function loadStatuses(){
    try {
      const who = await fetch("/whoami").then(r => r.json());

      if (who.logged_in) {
        setStatus("discordStatus", `Logged in as ${who.user.username}`, true);

        // Hide the "Login with Discord" button once logged in
        const loginBtn = document.querySelector('a[href="/login"]');
        if (loginBtn) loginBtn.style.display = "none";

        // --- Build OWNED-ONLY dropdown (Option B) ---
        // Always start with a clean placeholder option
        guildSelect.innerHTML = '<option value="">— Select a server —</option>';

        const ownedGuilds = (who.guilds || []).filter(g => g.owner);

        if (ownedGuilds.length) {
          for (const g of ownedGuilds) {
            const opt = document.createElement("option");
            opt.value = g.id;
            opt.textContent = g.name;
            guildSelect.appendChild(opt);
          }
        } else {
          // No owned servers: show a disabled message option
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No owned servers found";
          opt.disabled = true;
          opt.selected = true;
          guildSelect.appendChild(opt);
        }

        // Option B: keep all actions hidden/disabled until the user actually selects a server
        if (builderActions) {
          builderActions.style.display = "none";
        }
        btnLoadLive.disabled = true;
        btnLoadSnapshot.disabled = true;
        btnSave.disabled = true;

        // Force the change handler to run once to sync button disabled state
        guildSelect.dispatchEvent(new Event("change"));
      } else {
        setStatus("discordStatus", "Not logged in", false);

        // Not logged in: make sure actions are hidden/disabled and dropdown reset
        guildSelect.innerHTML = '<option value="">— Select a server —</option>';
        if (builderActions) {
          builderActions.style.display = "none";
        }
        btnLoadLive.disabled = true;
        btnLoadSnapshot.disabled = true;
        btnSave.disabled = true;
      }

      // Twitch status
      const env = await fetch("/envcheck").then(r => r.json());
      setStatus("twitchStatus", env.twitch ? "Connected" : "Not connected", !!env.twitch);

      // Plex status
      const plexResp = await fetch("/plex/status").then(r => r.json());
      if (plexResp.ok) {
        setStatus("plexStatus", "Plex reachable", true);
      } else {
        setStatus("plexStatus", "Not configured or unreachable", false);
      }
    } catch (e) {
      console.error("Status init error:", e);
    }
  }

  // Hide controls until selection
  el("btnLoadLive").style.display = "none";
  el("btnLoadSnapshot").style.display = "none";

  el("guildSelect").addEventListener("change", () => {
      const gid = el("guildSelect").value;
      if (gid) {
          el("btnLoadLive").style.display = "inline-block";
          el("btnLoadSnapshot").style.display = "inline-block";
          el("guildId").value = gid;
      } else {
          el("btnLoadLive").style.display = "none";
          el("btnLoadSnapshot").style.display = "none";
      }
  });

  el("btnPlexCheck").addEventListener("click", async () => {
    try {
      const r = await fetch("/plex/status").then(r=>r.json());
      if (r.ok){
        setStatus("plexStatus", "Plex reachable (code " + (r.status_code || 200) + ")", true);
      } else {
        setStatus("plexStatus", "Plex error: " + (r.error || r.status_code), false);
      }
    }catch(e){
      setStatus("plexStatus", "Plex error: " + e.message, false);
    }
  });

  el("btnLoadLive").addEventListener("click", async () => {
  const gid = guildSelect.value.trim();
  if (!gid) { alert("Select a server first"); return; }

  try {
    // Call the DASHBOARD, which proxies to the worker
    const res = await fetch(`/api/live_layout/${gid}`);
    if (!res.ok) {
      const text = await res.text();
      throw new Error("HTTP " + res.status + " — " + text.slice(0, 200));
    }
    const ct = res.headers.get("content-type") || "";
    if (!ct.includes("application/json")) {
      const text = await res.text();
      throw new Error("Non-JSON response: " + text.slice(0, 200));
    }

    const data = await res.json(); // This is the layout from snapshot_guild()

    // Worker returns: { mode, roles, categories, channels }
    const layout = data.categories || data.categories_channels || data;
    el("layoutJson").value = JSON.stringify(layout, null, 2);
    el("rolesJson").value = JSON.stringify(data.roles || [], null, 2);
    el("builderNote").textContent = "Loaded live layout for guild " + gid;
    renderLayout();
  } catch (e) {
    console.error(e);
    el("builderNote").textContent = "Failed to load from live: " + e.message;
  }
});

  document.getElementById("btnLoadSnapshot").addEventListener("click", async () => {
  const gid = guildSelect.value.trim();
  if (!gid) { alert("Select a server first"); return; }

  try {
    // Again: call dashboard, let it talk to the worker
    const res = await fetch(`/api/snapshot/${gid}`);
    if (!res.ok) {
      const text = await res.text();
      throw new Error("HTTP " + res.status + " — " + text.slice(0, 200));
    }
    const ct = res.headers.get("content-type") || "";
    if (!ct.includes("application/json")) {
      const text = await res.text();
      throw new Error("Non-JSON response: " + text.slice(0, 200));
    }

    const snap = await res.json(); // { ok: True/False, payload: {...} }
    if (!snap || !snap.ok || !snap.payload) {
      el("builderNote").textContent = "No snapshot found.";
      return;
    }

    const payload = snap.payload;
    const snapLayout = payload.categories || payload.categories_channels || payload;
    el("layoutJson").value = JSON.stringify(snapLayout, null, 2);
    el("rolesJson").value = JSON.stringify(payload.roles || [], null, 2);
    el("builderNote").textContent = "Loaded snapshot for guild " + gid;
    renderLayout(snapLayout);
  } catch (e) {
    console.error(e);
    el("builderNote").textContent = "Snapshot load failed: " + e.message;
  }
});

  el("btnSave").addEventListener("click", async () => {
    const gid = guildSelect.value.trim();
    if (!gid){ alert("Select a server first"); return; }

    let layout = collectLayoutFromUI();
    let roles = [];

    try { layout = JSON.parse(el("layoutJson").value || "{}"); } 
    catch(e){ return alert("Layout JSON is invalid"); }

    try { roles = JSON.parse(el("rolesJson").value || "[]"); } 
    catch(e){ return alert("Roles JSON is invalid"); }

    const payload = { guild_id: gid, layout, roles };

    const resp = await fetch("/submit-server-layout", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (resp.ok){
      el("builderNote").textContent = "Saved layout for guild " + gid;
    } else {
      const t = await resp.text();
      el("builderNote").textContent = "Save failed: " + t;
    }
  });

  loadStatuses();
});
function collectLayoutFromUI() {
  const categories = [];
  document.querySelectorAll(".category-block").forEach(block => {
    const name = block.querySelector(".category-name").value;
    const chList = block.querySelectorAll(".channel-row");

    const channels = Array.from(chList).map(row => ({
      type: row.querySelector(".channel-type").textContent,
      name: row.querySelector(".channel-name").value,
      options: {},
      position: 0
    }));

    categories.push({
      name,
      channels,
      position: 0
    });
  });
  return categories;
}


function renderLayout(layout) {
  const container = document.getElementById("categoryList");
  container.innerHTML = "";

  layout.forEach((cat, catIndex) => {
    const catDiv = document.createElement("div");
    catDiv.className = "category-block";
    
    const channelsId = `channels-${catIndex}`;
    
    catDiv.innerHTML = `
      <div class="category-header">
        <input class="category-name" value="${cat.name}">
        <button class="btn-small" onclick="addChannel(${catIndex})">+ Channel</button>
      </div>
      <div class="channel-list" id="${channelsId}"></div>
    `;
    
    container.appendChild(catDiv);

    const chContainer = document.getElementById(channelsId);

    cat.channels.forEach((ch, chIndex) => {
      const chDiv = document.createElement("div");
      chDiv.className = "channel-row";
      chDiv.innerHTML = `
        <span class="channel-type">${ch.type}</span>
        <input class="channel-name" value="${ch.name}">
      `;
      chContainer.appendChild(chDiv);
    });

    new Sortable(chContainer, {
      animation: 150,
      onEnd: () => saveVisualToJson()
    });
  });
}
</script>

</body>
</html>